---
description: "后端开发规范 - API 路由和服务层"
globs: ["src/app/api/**/*.ts", "src/services/**/*.ts", "src/lib/**/*.ts"]
alwaysApply: false
---

# 后端开发规范

## API 路由规范

### 路由结构
- 位置：`src/app/api/` 目录
- 文件名：`route.ts`
- HTTP 方法：GET, POST, PUT, DELETE, PATCH

```typescript
/**
 * 用户信息API
 * GET /api/user/info
 */
import { NextRequest, NextResponse } from 'next/server'
import { getUserFromToken } from '@/lib/auth'
import { successResponse, errorResponse } from '@/dto/response.dto'

export async function GET(request: NextRequest) {
  try {
    const user = await getUserFromToken(request)
    if (!user) {
      return NextResponse.json(errorResponse('未登录'), { status: 401 })
    }

    const userInfo = await getUserInfo(user.id)
    return NextResponse.json(successResponse(userInfo, '获取成功'))
  } catch (error) {
    console.error('获取用户信息失败:', error)
    return NextResponse.json(
      errorResponse('获取用户信息失败'),
      { status: 500 }
    )
  }
}
```

### 动态路由参数
```typescript
interface RouteParams {
  params: Promise<{ id: string }>
}

export async function GET(request: NextRequest, { params }: RouteParams) {
  const { id } = await params
  // 处理逻辑
}
```

## 响应格式规范

### 统一响应格式
```typescript
// src/dto/response.dto.ts
export interface ApiResponse<T = unknown> {
  status: boolean      // true: 成功, false: 失败
  message: string      // 提示信息
  data: T | null       // 响应数据
}

export function successResponse<T>(data: T, message = '操作成功'): ApiResponse<T> {
  return { status: true, message, data }
}

export function errorResponse(message = '操作失败', data: unknown = null): ApiResponse {
  return { status: false, message, data }
}
```

### HTTP 状态码
- **200**: 成功
- **201**: 创建成功
- **400**: 请求参数错误
- **401**: 未授权/未登录
- **403**: 无权限
- **404**: 资源不存在
- **500**: 服务器错误

## 服务层规范

### 服务层组织
- 位置：`src/services/` 目录
- 命名：按业务模块命名（如 `post.ts`, `user.ts`）
- 职责：封装业务逻辑和数据库操作

#### AI 服务目录结构
AI 相关服务统一组织在 `src/services/ai/` 目录下，按功能拆分：

```
src/services/ai/
├── anthropic/        # Anthropic 官方 SDK 工具类（新建）
│   ├── client.ts     # 客户端和配置
│   ├── stream.ts     # 流式响应处理
│   └── index.ts      # 统一导出
├── text/              # AI文本处理服务（使用 Anthropic）
│   └── index.ts
├── description/       # 文章描述生成服务（使用 Anthropic）
│   └── index.ts
├── utils/            # 共享工具函数（提示词模板创建等，用于 OpenAI）
│   └── prompt.ts
└── index.ts          # 统一导出接口
```

**导入规范**：
```typescript
// ✅ 正确：从统一入口导入服务
import { processAITextStream, generDescriptionStream } from '@/services/ai';

// ✅ 正确：直接导入 Anthropic 工具类（需要直接调用时）
import { streamAnthropicMessagesWithSystem } from '@/services/ai/anthropic';

// ✅ 正确：导入 OpenAI LangChain 工具（需要 OpenAI 时）
import { createAIChain, streamFromChain } from '@/lib/ai';

// ❌ 错误：不要混用两套工具
// 不要用 LangChain 调用 Anthropic，不要用官方 SDK 调用 OpenAI
```

**目录职责**：
- `anthropic/` - Anthropic 官方 SDK 工具类，提供直接调用接口
- `text/` - AI 文本处理相关功能（使用 Anthropic）
- `description/` - 文章描述生成功能（使用 Anthropic）
- `utils/` - 共享的工具函数（主要用于 OpenAI 的 LangChain 提示词模板）
- `index.ts` - 统一导出所有核心接口，方便其他模块使用

```typescript
// src/services/post.ts
import { getPrisma } from '@/lib/prisma'

/**
 * 获取文章列表
 */
export async function getPostList(params: {
  pageNum?: number
  pageSize?: number
  hide?: string
}) {
  const { pageNum = 1, pageSize = 10, hide = '0' } = params
  const prisma = await getPrisma()

  const where = {
    is_delete: 0,
    ...(hide !== 'all' && { hide }),
  }

  const [record, total] = await Promise.all([
    prisma.tbPost.findMany({
      where,
      orderBy: { date: 'desc' },
      take: pageSize,
      skip: (pageNum - 1) * pageSize,
    }),
    prisma.tbPost.count({ where }),
  ])

  return { record, total, pageNum, pageSize }
}
```

## 认证和授权

### Token 认证

#### 基础 Token 认证
```typescript
// src/lib/auth.ts
import { NextRequest } from 'next/server'
import { getRedis } from '@/lib/redis'

export const TOKEN_KEY = 'auth_token'

/**
 * 从请求中获取用户信息
 */
export async function getUserFromToken(request: NextRequest) {
  const token = request.cookies.get(TOKEN_KEY)?.value
  if (!token) return null

  const redis = await getRedis()
  const userStr = await redis.get(`token:${token}`)
  if (!userStr) return null

  return JSON.parse(userStr)
}

/**
 * 验证用户权限
 */
export async function checkPermission(
  request: NextRequest,
  requiredRole: string
): Promise<boolean> {
  const user = await getUserFromToken(request)
  if (!user) return false

  return user.role === requiredRole || user.role === 'admin'
}
```

#### 使用 withAuth 中间件（推荐）

**推荐方式**：使用 `withAuth` 中间件可以简化认证逻辑，同时支持普通Token和长期Token。

```typescript
// src/app/api/example/protected/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withAuth } from '@/lib/long-term-token-auth';
import { successResponse } from '@/dto/response.dto';

/**
 * GET /api/example/protected - 需要认证的API示例
 * 支持两种认证方式：
 * 1. 普通Token: Authorization: Bearer <token> (7天有效期)
 * 2. 长期Token: Authorization: Bearer <LTK_xxx> (30天或永久)
 */
export const GET = withAuth(async (userId, request) => {
  // 在这里处理业务逻辑，userId是已验证的用户ID
  // 可以访问 userId 来获取用户特定的数据

  return NextResponse.json(
    successResponse({
      message: '认证成功！',
      userId,
      timestamp: new Date().toISOString(),
      data: {
        note: '这是一个受保护的API示例',
        supportedAuth: ['regular token', 'long-term token'],
      },
    })
  );
});

/**
 * POST /api/example/protected - 需要认证的POST示例
 */
export const POST = withAuth(async (userId, request) => {
  try {
    const body = await request.json();

    // 处理业务逻辑
    // userId 是已验证的用户ID

    return NextResponse.json(
      successResponse({
        message: '数据处理成功！',
        userId,
        receivedData: body,
        timestamp: new Date().toISOString(),
      })
    );
  } catch (error) {
    // 如果JSON解析失败
    return NextResponse.json(
      successResponse({
        message: '处理成功（无请求体数据）',
        userId,
        timestamp: new Date().toISOString(),
      })
    );
  }
});
```

**withAuth 中间件的特点**：
- ✅ 自动处理认证逻辑，减少重复代码
- ✅ 同时支持普通Token和长期Token（以 `LTK_` 开头）
- ✅ 自动返回 401 未授权错误
- ✅ 处理函数自动接收已验证的 `userId` 参数
- ✅ 统一错误处理

**使用场景**：
- 需要认证的API端点
- 同时支持短期和长期Token的场景
- 简化认证代码，提高可维护性

## 数据验证

### 使用 Zod 验证
```typescript
import { z } from 'zod'

const createPostSchema = z.object({
  title: z.string().min(1, '标题不能为空').max(100, '标题不能超过100个字符'),
  content: z.string().min(1, '内容不能为空'),
  category: z.string().optional(),
  tags: z.array(z.string()).optional(),
  hide: z.enum(['0', '1']).default('0'),
})

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const validatedData = createPostSchema.parse(body)

    const post = await createPost(validatedData)
    return NextResponse.json(successResponse(post, '创建成功'))
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        errorResponse(error.errors[0].message),
        { status: 400 }
      )
    }
    return NextResponse.json(errorResponse('创建失败'), { status: 500 })
  }
}
```

## 缓存策略

### Redis 缓存
```typescript
import { getRedis } from '@/lib/redis'

/**
 * 获取用户信息（带缓存）
 */
export async function getUserInfo(userId: string) {
  const redis = await getRedis()
  const cacheKey = `user:${userId}`

  // 1. 尝试从缓存获取
  const cached = await redis.get(cacheKey)
  if (cached) return JSON.parse(cached)

  // 2. 从数据库查询
  const prisma = await getPrisma()
  const user = await prisma.tbUser.findUnique({ where: { id: userId } })
  if (!user) return null

  // 3. 写入缓存（24小时过期）
  await redis.setex(cacheKey, 86400, JSON.stringify(user))

  return user
}
```

## 错误处理

### 分层错误处理
```typescript
// 业务错误类
export class BusinessError extends Error {
  constructor(
    message: string,
    public statusCode: number = 400
  ) {
    super(message)
    this.name = 'BusinessError'
  }
}

// 服务层抛出错误
export async function createPost(data: PostData) {
  if (!data.title) {
    throw new BusinessError('标题不能为空', 400)
  }

  const existing = await getPostByTitle(data.title)
  if (existing) {
    throw new BusinessError('标题已存在', 409)
  }

  return await prisma.tbPost.create({ data })
}

// API 路由捕获错误
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const post = await createPost(body)
    return NextResponse.json(successResponse(post, '创建成功'))
  } catch (error) {
    if (error instanceof BusinessError) {
      return NextResponse.json(
        errorResponse(error.message),
        { status: error.statusCode }
      )
    }

    console.error('创建文章失败:', error)
    return NextResponse.json(errorResponse('创建文章失败'), { status: 500 })
  }
}
```

## 性能优化

### 数据库查询优化
```typescript
// ✅ 并行查询
const [posts, count] = await Promise.all([
  prisma.tbPost.findMany({ where }),
  prisma.tbPost.count({ where }),
])

// ✅ 只查询需要的字段
const posts = await prisma.tbPost.findMany({
  select: {
    id: true,
    title: true,
    date: true,
    // 不查询 content 字段
  },
})

// ✅ 使用 include 避免 N+1 查询
const posts = await prisma.tbPost.findMany({
  include: {
    user: true,
  },
})
```

## 安全规范

### 密码安全
```typescript
import bcrypt from 'bcryptjs'

// 密码加密
const hashedPassword = await bcrypt.hash(password, 10)

// 密码验证
const isValid = await bcrypt.compare(password, hashedPassword)
```

### 敏感信息保护
```typescript
// ✅ 不返回敏感字段
const user = await prisma.tbUser.findUnique({
  where: { id },
  select: {
    id: true,
    nickname: true,
    avatar: true,
    // 不返回 password 字段
  },
})

// ✅ 使用环境变量
const secret = process.env.JWT_SECRET
```

## 数据库集成

### 数据库操作规范
本项目使用 Prisma 作为 ORM，但**不使用 Prisma Migrate**，而是手写 SQL 迁移脚本。

详细规范请参考：`database.mdc`

#### 常用命令
```bash
# 生成 Prisma Client
pnpm prisma generate

# 查看 Schema
pnpm prisma studio

# 数据库推送（开发环境）
pnpm prisma db push
```

## 流式响应规范

### 概述
本项目默认使用**流式响应**处理 AI 相关的 API 请求，提供实时的打字机效果和更好的用户体验。

### AI 服务技术栈（两套独立工具）

本项目使用**两套独立的 AI 工具**，根据不同的模型提供商选择：

#### 1. Anthropic Claude（官方 SDK）
- **位置**：`@/services/ai/anthropic`
- **SDK**：`@anthropic-ai/sdk` 官方 SDK
- **特点**：直接调用，支持中转服务，无需 LangChain 包装
- **使用场景**：所有 Anthropic Claude 模型调用

#### 2. OpenAI（LangChain 包装）
- **位置**：`@/lib/ai.ts`
- **SDK**：`@langchain/openai` + LangChain.js
- **特点**：使用 LangChain LCEL 规范，统一的链式调用接口
- **使用场景**：所有 OpenAI 模型调用

### 工具选择规范

**重要：必须根据模型提供商明确选择使用哪套工具**

#### Anthropic Claude 使用规范

```typescript
// ✅ 正确：使用官方 SDK 工具
import {
  streamAnthropicMessagesWithSystem,
  type AnthropicModelConfig,
} from '@/services/ai/anthropic';

// 调用方式
const stream = await streamAnthropicMessagesWithSystem(
  systemInstruction,  // 系统消息（字符串）
  messages,           // 消息数组 [{ role: 'user' | 'assistant', content: string }]
  config              // AnthropicModelConfig
);
```

**特点**：
- 直接返回 `ReadableStream<Uint8Array>`
- 流式数据是**纯文本**，直接解码即可
- 支持中转服务（通过 baseURL 配置）
- 消息格式：使用 `system` 参数传递系统消息，`messages` 数组传递对话消息

#### OpenAI 使用规范

```typescript
// ✅ 正确：使用 LangChain 工具
import {
  ChatPromptTemplate,
  createAIChain,
  streamFromChain,
  type AIModelConfig,
} from '@/lib/ai';

// 创建提示词模板
const prompt = ChatPromptTemplate.fromMessages([
  ['system', '系统指令'],
  ['human', '{input}'],
]);

// 创建 AI 链（使用 LCEL）
const chain = createAIChain<{ input: string }>(prompt, {
  model: 'gpt-4o-mini',
  temperature: 0.7,
  maxTokens: 2000,
});

// 执行流式响应
const stream = await streamFromChain(chain, { input: '用户输入' });
```

**特点**：
- 使用 LangChain LCEL 规范：`prompt.pipe(model).pipe(outputParser)`
- 返回 `ReadableStream<Uint8Array>`
- 流式数据是**纯文本**，直接解码即可
- 支持提示词模板和链式调用

### 前端解析方案

**重要：两套工具返回的流式数据格式相同，但解析方式需要统一处理**

#### 统一的前端解析方案

```typescript
/**
 * 处理流式响应（适用于 Anthropic 和 OpenAI）
 * @param response Response 对象
 * @param onChunk 每个数据块的回调
 * @param onComplete 完成回调
 */
const handleStreamResponse = async (
  response: Response,
  onChunk: (text: string) => void,
  onComplete?: (fullText: string) => void
) => {
  const reader = response.body?.getReader();
  if (!reader) {
    throw new Error('无法读取响应流');
  }

  const decoder = new TextDecoder('utf-8');
  let fullText = '';

  try {
    while (true) {
      const { done, value } = await reader.read();
      
      if (done) {
        onComplete?.(fullText);
        break;
      }

      if (value) {
        // 直接解码为文本（两套工具都返回纯文本）
        const text = decoder.decode(value, { stream: true });
        fullText += text;
        onChunk(text);
      }
    }
  } catch (error) {
    console.error('处理流式响应错误:', error);
    throw error;
  } finally {
    reader.releaseLock();
  }
};
```

#### 使用示例

```typescript
// 调用 Anthropic API
const response = await fetch('/api/ai/description', {
  method: 'POST',
  body: JSON.stringify({ content: '文章内容' }),
});

// 使用统一的解析方案
await handleStreamResponse(
  response,
  (chunk) => {
    // 实时更新显示
    setContent((prev) => prev + chunk);
  },
  (fullText) => {
    // 完成处理
    console.log('完整内容:', fullText);
  }
);
```

**注意**：
- 两套工具返回的都是 `ReadableStream<Uint8Array>`
- 流式数据都是**纯文本**，使用 `TextDecoder` 直接解码
- 不需要区分是哪个工具返回的，统一使用相同的解析方案
- HTTP 响应头都是 `text/plain; charset=utf-8` 或 `text/event-stream; charset=utf-8`

### 流式响应原则
1. **默认使用流式**：所有 AI 处理相关的 API 都应该使用流式响应
2. **移除非流式代码**：删除冗余的非流式处理逻辑，减少代码复杂度
3. **统一接口**：客户端调用方式保持一致，无需关心是否流式

### 服务层实现

#### Anthropic 服务实现示例

```typescript
// src/services/ai/text/index.ts - AI文本处理服务（使用 Anthropic）
import {
  streamAnthropicMessagesWithSystem,
  type AnthropicModelConfig,
} from '../anthropic';
import { AI_PROMPTS, type AIProcessParams, type AIActionType } from '@/lib/ai-text';

/**
 * AI文本处理（流式）
 * @param params 处理参数
 * @returns ReadableStream 流式响应
 */
export const processAITextStream = async (
  params: AIProcessParams
): Promise<ReadableStream> => {
  const { text, action, context } = params;
  
  // 输入验证
  if (!text || text.trim().length === 0) {
    throw new Error('文本内容不能为空');
  }
  
  if (text.length > 5000) {
    throw new Error('文本长度超过限制（5000字符）');
  }

  // 获取指令
  const instruction = AI_PROMPTS[action];
  
  // 构建系统指令
  const systemInstruction = `请使用中文回复。

${instruction}`;

  // 构建用户消息
  let userContent = '';
  if (context) {
    userContent = `上下文信息：${context}\n\n需要处理的文本：${text}`;
  } else {
    userContent = text;
  }

  const messages = [
    {
      role: 'user' as const,
      content: userContent,
    },
  ];

  // 使用 Anthropic 官方 SDK
  return streamAnthropicMessagesWithSystem(
    systemInstruction,
    messages,
    {
      model: 'claude-haiku-4-5-20251001',
      temperature: 0.7,
      maxTokens: 2000,
    }
  );
};
```

#### OpenAI 服务实现示例

```typescript
// src/app/api/chat/route.ts - 聊天API（使用 OpenAI LangChain）
import {
  ChatPromptTemplate,
  createAIChain,
  streamFromChain,
  type AIModelConfig,
} from '@/lib/ai';

// 创建提示词模板
const prompt = ChatPromptTemplate.fromMessages([
  ['system', systemInstruction],
  ['human', userTemplate],
]);

// 创建 AI 链（使用 LCEL）
const chain = createAIChain<{ message: string }>(prompt, {
  model: 'gpt-4o-mini',
  temperature: 0.7,
  maxTokens: 2000,
});

// 执行流式响应
const stream = await streamFromChain(chain, { message });
```

#### 工具函数说明

**注意**：`src/services/ai/utils/prompt.ts` 中的工具函数主要用于 OpenAI 的 LangChain 提示词模板创建。对于 Anthropic，直接使用字符串构建系统指令和消息即可。

```typescript
// src/services/ai/utils/prompt.ts - 提示词工具函数（主要用于 OpenAI）
import { ChatPromptTemplate } from '@/lib/ai';

// 这些函数返回 ChatPromptTemplate，用于 OpenAI 的 LangChain 链
export const createBasePrompt = (
  systemInstruction: string,
  userTemplate: string
): ChatPromptTemplate => {
  return ChatPromptTemplate.fromMessages([
    ['system', systemInstruction],
    ['human', userTemplate],
  ]);
};
```

**Anthropic 不需要这些工具函数**，直接构建字符串即可：

```typescript
// ✅ Anthropic 方式：直接使用字符串
const systemInstruction = `请使用中文回复。

你是一个AI助手。`;
const messages = [{ role: 'user' as const, content: '用户输入' }];
```

### API 路由实现

#### Anthropic 流式 API 路由
```typescript
// src/app/api/ai/process/route.ts（使用 Anthropic）
import { NextRequest, NextResponse } from 'next/server';
import { processAITextStream } from '@/services/ai';

/**
 * 创建流式响应
 */
const createStreamResponse = (stream: ReadableStream): Response => {
  return new Response(stream, {
    headers: {
      'Content-Type': 'text/plain; charset=utf-8',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
};

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { text, action, context } = body;

    // 验证参数...
    
    // 流式处理（内部使用 Anthropic 官方 SDK）
    const streamResponse = await processAITextStream({ text, action, context });
    return createStreamResponse(streamResponse);
  } catch (error) {
    return NextResponse.json(
      { status: false, message: error instanceof Error ? error.message : '处理失败' },
      { status: 500 }
    );
  }
}
```

#### OpenAI 流式 API 路由
```typescript
// src/app/api/chat/route.ts（使用 OpenAI LangChain）
import { NextRequest, NextResponse } from 'next/server';
import { createAIChain, streamFromChain, ChatPromptTemplate } from '@/lib/ai';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { message, history } = body;

    // 创建提示词模板
    const prompt = ChatPromptTemplate.fromMessages([
      ['system', '系统指令'],
      ['human', '{message}'],
    ]);

    // 创建 AI 链（使用 LCEL）
    const chain = createAIChain<{ message: string }>(prompt, {
      model: 'gpt-4o-mini',
      temperature: 0.7,
      maxTokens: 2000,
    });

    // 执行流式响应
    const stream = await streamFromChain(chain, { message });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream; charset=utf-8',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });
  } catch (error) {
    return NextResponse.json(
      { status: false, message: error instanceof Error ? error.message : '处理失败' },
      { status: 500 }
    );
  }
}
```

### 客户端调用

#### 统一的流式处理客户端

**重要**：两套工具返回的流式数据格式相同，前端使用统一的解析方案。

```typescript
// src/components/AITextProcessor/ProcessingModal.tsx
const processText = useCallback(async () => {
  setIsLoading(true);
  setError(null);
  setStreamText('');

  try {
    // 调用流式 API（无论是 Anthropic 还是 OpenAI）
    const response = await callAIAPI({
      text: originalText,
      action: action,
    });

    // 统一的流式响应解析（适用于两套工具）
    const reader = response.body?.getReader();
    if (!reader) {
      throw new Error('无法读取响应流');
    }

    const decoder = new TextDecoder('utf-8');
    let fullText = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      // 直接解码为文本（两套工具都返回纯文本）
      const chunk = decoder.decode(value, { stream: true });
      fullText += chunk;
      setStreamText(fullText); // 实时更新显示
    }

    setResult(fullText);
    setIsLoading(false);
  } catch (error) {
    setError(error instanceof Error ? error.message : '处理失败');
    setIsLoading(false);
  }
}, [originalText, action]);
```

**关键点**：
- 两套工具返回的都是 `ReadableStream<Uint8Array>`
- 流式数据都是**纯文本**，使用 `TextDecoder` 直接解码
- **不需要区分**是哪个工具返回的，统一使用相同的解析方案
- HTTP 响应头都是 `text/plain; charset=utf-8` 或 `text/event-stream; charset=utf-8`

### 客户端工具函数

```typescript
// src/services/ai-text.ts
/**
 * 调用AI处理API（流式）
 * @param params 处理参数
 * @returns Response 对象用于流式读取
 */
export const callAIAPI = async (
  params: AIProcessParams
): Promise<Response> => {
  const response = await fetch('/api/ai/process', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(params), // 不需要 stream 参数
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}`);
  }

  return response; // 直接返回 Response 用于流式读取
};
```

### 流式处理工具

```typescript
// src/lib/stream.ts
/**
 * 处理流式响应
 */
export const processStreamResponse = async (
  response: Response,
  options: StreamProcessOptions
): Promise<string> => {
  const reader = response.body?.getReader();
  const decoder = new TextDecoder();
  let accumulatedText = '';

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    const chunk = decoder.decode(value, { stream: true });
    accumulatedText += chunk;
    options.onChunk?.(chunk);
  }

  options.onComplete?.(accumulatedText);
  return accumulatedText;
};
```

### 优势

1. **实时反馈**：用户可以立即看到 AI 生成的内容
2. **更好的 UX**：打字机效果提供更好的用户体验
3. **代码简化**：移除非流式逻辑，减少代码复杂度
4. **统一接口**：所有 AI 处理都使用相同的模式

### 工具选择决策树

**如何选择使用哪套工具？**

```
需要调用 AI 模型
├── 模型提供商是 Anthropic Claude？
│   └── 是 → 使用 @/services/ai/anthropic（官方SDK）
│       └── 支持中转服务，直接调用
│
└── 模型提供商是 OpenAI？
    └── 是 → 使用 @/lib/ai（LangChain 包装）
        └── 使用 LCEL 链式调用
```

**明确指定工具的使用方式**：

1. **Anthropic 场景**：
   - 文章描述生成 → 使用 `@/services/ai/anthropic`
   - AI 文本处理 → 使用 `@/services/ai/anthropic`
   - 需要支持中转服务 → 使用 `@/services/ai/anthropic`

2. **OpenAI 场景**：
   - 聊天对话（知识库检索） → 使用 `@/lib/ai`（LangChain）
   - 需要 LCEL 链式调用 → 使用 `@/lib/ai`（LangChain）

### 注意事项

- **工具选择**：必须根据模型提供商明确选择工具，不要混用
- **流式响应**：所有 AI 相关 API 必须支持流式响应
- **统一格式**：两套工具返回的流式数据格式相同，前端使用统一解析方案
- **HTTP 头**：流式响应需要设置正确的 HTTP 头（`Cache-Control: no-cache`）
- **错误处理**：错误信息也应该通过流式返回，避免客户端等待超时
- **中转服务**：Anthropic 使用官方 SDK 可以支持中转服务，LangChain 包装可能不支持

## MCP 服务器规范

### 概述
MCP (Model Context Protocol) 服务器用于为 AI 助手提供标准化的上下文和工具访问。本项目在 `src/app/api/mcp/route.ts` 实现 MCP 服务器。

### Resource vs Tool 原则

#### 使用 Resource（资源）
- **场景**：暴露静态或半静态数据供查询
- **特点**：只读、可缓存、可订阅
- **示例**：标签列表、分类、配置数据

```typescript
// ✅ 正确：标签作为资源
server.registerResource(
  "tags",
  "blog://tags",
  {
    title: "Available Blog Tags",
    description: "List of all available tags with usage counts",
    mimeType: "application/json"
  },
  async () => {
    const tags = await getAllTags();
    return {
      contents: [{
        uri: "blog://tags",
        mimeType: "application/json",
        text: JSON.stringify(tags, null, 2)
      }]
    };
  }
);
```

#### 使用 Tool（工具）
- **场景**：执行操作、修改状态、调用 API
- **特点**：有副作用、动态操作
- **示例**：创建文章、更新数据、删除记录

```typescript
// ✅ 正确：创建文章作为工具
server.registerTool(
  "create_article",
  {
    title: "Create article",
    description: "Create a new blog article",
    inputSchema: {
      title: z.string(),
      content: z.string(),
      tags: z.string().optional()
    }
  },
  async (args) => {
    const result = await createPost(args);
    return {
      content: [{ type: "text", text: JSON.stringify(result) }]
    };
  }
);
```

### Resource 设计规范

#### URI 格式
```typescript
// 使用自定义协议 + 资源名
"blog://tags"           // 标签资源
"blog://categories"     // 分类资源
"blog://posts/{id}"     // 文章资源（模板）
```

#### 返回格式
```typescript
{
  contents: [{
    uri: string,
    mimeType: string,  // "application/json" 或 "text/plain"
    text?: string,     // 文本内容
    blob?: string      // base64 编码的二进制内容
  }]
}
```

#### 认证处理
```typescript
// 所有 Resource 都需要认证
async () => {
  await ensureAuth();  // 验证请求头中的认证信息
  const data = await getData();
  return { contents: [...] };
}
```

### Tool 设计规范

#### 描述引用 Resource
```typescript
// ✅ 在描述中引用相关资源
server.registerTool("create_article", {
  description: "Create article. First read 'blog://tags' resource to check existing tags.",
  // ...
});
```

#### 参数说明
```typescript
inputSchema: {
  tags: z.string().optional().describe(
    "Comma-separated tags. Check 'blog://tags' resource first"
  )
}
```

### 常见模式

#### 1. 查询 + 操作模式
```typescript
// LLM 流程：
// 1. 读取 Resource: blog://tags
// 2. 匹配/选择标签
// 3. 调用 Tool: create_article
```

#### 2. 数据验证模式
```typescript
// Resource 提供参考数据
// Tool 验证并执行操作
```

### 实现示例

#### 完整的 MCP 服务器
```typescript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

function createMcpServer(headers: Headers) {
  const server = new McpServer({
    name: "React Blog MCP",
    version: "1.0.0"
  });

  // 认证辅助函数
  const ensureAuth = async () => {
    const account = headers.get('x-mcp-account');
    const password = headers.get('x-mcp-password');
    // ... 认证逻辑
  };

  // 注册 Resource
  server.registerResource("tags", "blog://tags", {
    title: "Available Tags",
    mimeType: "application/json"
  }, async () => {
    await ensureAuth();
    const tags = await getAllTags();
    return {
      contents: [{
        uri: "blog://tags",
        mimeType: "application/json",
        text: JSON.stringify(tags)
      }]
    };
  });

  // 注册 Tool
  server.registerTool("create_article", {
    description: "Create article. Check 'blog://tags' resource first.",
    inputSchema: {
      title: z.string(),
      tags: z.string().optional()
    }
  }, async (args) => {
    await ensureAuth();
    const result = await createPost(args);
    return {
      content: [{ type: "text", text: JSON.stringify(result) }]
    };
  });

  return server;
}
```

### 测试验证

```bash
# 检查代码质量
pnpm lint src/app/api/mcp/route.ts

# 验证实现
pnpm dev
# 发送测试请求到 /api/mcp
```

### MCP 认证规范

#### ⚠️ 认证方式改造计划

**当前状态**: 使用自定义头部 `x-mcp-account`/`x-mcp-password` 进行认证
**目标状态**: 使用标准 `Authorization: Bearer <token>` 方式

**问题**: 当前实现**不兼容**官方 MCP 客户端，因为：
1. 官方客户端只支持标准 OAuth 2.0 Bearer Token
2. MCP SDK 通过 `req.auth` 传递 `AuthInfo` 对象
3. 自定义头部无法被标准客户端识别

**详细计划**: `docs/MCP_AUTH_REFACTOR_PLAN.md`

#### 当前实现（待改造）
```typescript
// src/app/api/mcp/route.ts:82-83
const account = headers.get('x-mcp-account') || process.env.MCP_USER_ACCOUNT;
const password = headers.get('x-mcp-password') || process.env.MCP_USER_PASSWORD;
```

#### 目标实现
```typescript
// 1. 创建认证适配器
// src/services/mcpAuth.ts
import { validateToken } from '@/lib/auth';
import type { OAuthTokenVerifier } from '@modelcontextprotocol/sdk/server/auth/provider';

export const mcpAuthVerifier: OAuthTokenVerifier = {
  async verifyAccessToken(token: string): Promise<AuthInfo> {
    const user = await validateToken(token);
    if (!user) throw new Error("Invalid token");

    return {
      token,
      clientId: `mcp-client-${user.id}`,
      scopes: ['read', 'write'],
      expiresAt: undefined,
      extra: { userId: user.id, role: user.role }
    };
  }
};

// 2. 更新 MCP 路由认证逻辑
// src/app/api/mcp/route.ts
const ensureAuth = async () => {
  const authHeader = headers.get('authorization');
  if (!authHeader?.startsWith('Bearer ')) {
    throw new Error("Use 'Authorization: Bearer <token>'");
  }

  const token = authHeader.substring(7);
  const user = await validateToken(token);
  if (!user) throw new Error("Invalid token");

  return user;
};
```

#### 迁移步骤

1. **准备阶段**
   - 备份当前 `src/app/api/mcp/route.ts`
   - 确认测试环境可用

2. **实施阶段**
   - 创建 `src/services/mcpAuth.ts`
   - 更新 MCP 路由认证逻辑
   - 保持所有工具功能不变

3. **验证阶段**
   - 测试 Bearer token 认证
   - 验证所有 MCP 工具
   - 确认错误处理

4. **客户端改造**
   ```typescript
   // 改造前
   fetch('/api/mcp', {
     headers: {
       'x-mcp-account': 'admin',
       'x-mcp-password': 'password'
     }
   })

   // 改造后
   const token = await login(); // 先登录获取 token
   fetch('/api/mcp', {
     headers: {
       'Authorization': `Bearer ${token}`
     }
   })
   ```

#### 预计工作量
- 核心改造: 2-3 小时
- 测试验证: 1-2 小时
- 文档更新: 30 分钟
- **总计**: 3.5-5.5 小时

#### 相关文件
- `src/app/api/mcp/route.ts` - 主要改造文件
- `src/services/mcpAuth.ts` - 新增认证适配器（待创建）
- `src/lib/auth.ts` - 现有 Token 验证函数（可复用）
- `docs/MCP_AUTH_REFACTOR_PLAN.md` - 完整计划文档

#### 参考资料
- [MCP 官方文档](https://modelcontextprotocol.io)
- [MCP 规范](https://spec.modelcontextprotocol.io)
- 项目文档：`docs/mcp_resources_tags.md`
