# 博客文章增量向量化与版本管理需求文档

## 1. 背景与目标

当前博客系统基于 Next.js + Prisma 构建，文章内容以 Markdown 字符串形式存储在数据库 `tb_post.content` 字段中。在文章保存时，会对文章内容调用嵌入式模型（Embedding Model）生成向量并写入向量数据库，用于搜索、推荐或 RAG 等能力。

**问题：**
- 每次保存都会全量重新向量化，Embedding 调用成本高、耗时大。
- 实际上很多保存并未产生“语义级”的有效变化（如格式调整、错别字修复）。

**目标：**
- 在保存文章时，能够**准确判断哪些内容发生了有效变化**。
- 仅对发生变化的内容进行向量化（增量更新）。
- 同时保留文章历史版本，用于 diff 对比和回滚。

---

## 2. 总体设计原则

1. **版本可回滚优先于存储最小化**
   - 数据库存储完整版本快照，而不是纯 diff 链。
2. **Embedding 判断基于“语义块变更”，而不是全文字符串 diff**
3. **Diff 的主要用途是“展示与审计”，而非系统决策**
4. **系统可逐步演进（先简单分块 → AST 级分块）**

---

## 3. 核心概念定义

### 3.1 文章版本（Post Version）
- 表示文章在某一次保存后的完整状态
- 用于：历史查看、diff 对比、回滚

### 3.2 内容块（Chunk）
- 将 Markdown 内容按语义拆分后的最小处理单元
- Chunk 是向量化与变更判断的基本单位

### 3.3 Chunk Hash
- 对 Chunk 内容进行规范化后计算的哈希值
- 用于判断 Chunk 是否发生变化

---

## 4. 数据模型设计

### 4.1 文章主表（已存在）

```prisma
model TbPost {
  id          Int     @id @default(autoincrement())
  title       String?
  content     String? @db.Text
  updated     DateTime?
}
```

### 4.2 文章版本表（新增）

```prisma
model TbPostVersion {
  id          Int       @id @default(autoincrement())
  post_id     Int
  version     Int
  content     String    @db.LongText
  created_at  DateTime  @default(now())
  created_by  Int?

  post        TbPost    @relation(fields: [post_id], references: [id])

  @@index([post_id, version])
}
```

### 4.3 文章内容块表（新增）

```prisma
model TbPostChunk {
  id           String   @id              // 稳定 Chunk ID
  post_id      Int
  version      Int
  type         String   // section | code | list | paragraph
  content      String   @db.Text
  hash         String   // 内容 hash
  embedding_id String?  // 向量库中的 ID
  created_at   DateTime @default(now())

  @@index([post_id])
}
```

---

## 5. Markdown 分块策略

### 5.1 分块原则

- 按“语义结构”而非字符位置拆分
- 初期可采用简化方案，后续可升级

### 5.2 初期实现（MVP）

- 按 Markdown 标题（`##`）切分
- 每个标题及其下属内容作为一个 Chunk

### 5.3 进阶实现（推荐）

- 使用 `remark` 解析 Markdown AST
- Chunk 类型包括：
  - Heading + 内容（Section）
  - Code Block
  - List
  - Quote

---

## 6. Chunk 稳定 ID 设计

**目标：** 内容未变时，ID 不变；顺序变化不导致全量失效。

推荐规则：

```text
chunkId = hash(postId + headingPath + chunkType)
```

- headingPath 示例：`#前言/##背景`
- 避免使用数组 index 作为 ID

---

## 7. 内容规范化（Hash 前处理）

在计算 hash 前，对内容进行规范化，避免无效变更触发更新。

示例规则：
- 去除首尾空白
- 统一换行符（\r\n → \n）
- 多个空行压缩为最多 2 个
- 可选：去除 Markdown 标记，仅保留文本

---

## 8. 保存流程设计（核心流程）

```text
用户保存文章
  ↓
解析 Markdown → Chunks
  ↓
加载上一版本的 Chunks
  ↓
按 chunkId 对比 hash
  ↓
┌ unchanged → 复用旧 embedding
├ changed   → 调用 embedding 模型
└ deleted  → 从向量库删除
  ↓
向量库 upsert
  ↓
保存 TbPostVersion（完整快照）
  ↓
更新 TbPost.content
```

---

## 9. 向量数据库交互要求

- 向量最小单位：Chunk
- 向量 payload 至少包含：
  - post_id
  - chunk_id
  - version

示例 payload：

```json
{
  "post_id": 12,
  "chunk_id": "post12_section_intro",
  "version": 5
}
```

---

## 10. Diff 与版本对比

### 10.1 Diff 的用途

- 管理后台版本对比展示
- 审计、回溯修改记录
- GitHub Issue / 日志同步

### 10.2 实现方式

- Diff 可实时计算（oldVersion.content vs newVersion.content）
- 使用行级 diff（如 `diffLines`）
- Diff 不作为 embedding 决策依据

---

## 11. 回滚策略

- 回滚本质：选定历史版本内容，生成一个**新版本**
- 不直接删除或覆盖历史版本

流程：
1. 选择目标版本
2. 使用该版本 content 覆盖当前内容
3. 触发一次正常保存流程（生成新 version）

---

## 12. 非功能性要求

- 单次保存中，Embedding 调用次数 ≈ 实际变更 Chunk 数
- 支持后续更换 Embedding 模型
- 向量更新与数据库写入需具备失败可重试能力

---

## 13. 后续可扩展方向（非本期）

- 自动草稿与定时保存（Draft Chunk）
- Markdown AST 级语义 Diff
- 多人协作编辑与冲突合并
- 与 GitHub Issue / PR 自动同步

---

## 14. 验收标准

- 未修改内容保存时，不触发 Embedding 调用
- 修改单个段落，仅对应 Chunk 重新向量化
- 可查看任意历史版本内容
- 可进行版本 diff 对比与安全回滚

